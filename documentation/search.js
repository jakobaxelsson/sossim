window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "agent", "modulename": "agent", "kind": "module", "doc": "<p>Provides concrete agents for the SoSSim system-of-systems simulator.</p>\n"}, {"fullname": "agent.Vehicle", "modulename": "agent", "qualname": "Vehicle", "kind": "class", "doc": "<p>Base class for a model agent.</p>\n", "bases": "sos_core.SoSAgent"}, {"fullname": "agent.Vehicle.__init__", "modulename": "agent", "qualname": "Vehicle.__init__", "kind": "function", "doc": "<p>Creates a vehicle agent in a simulation model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>unique_id (int):</strong>  the unique id of the agent.</li>\n<li><strong>model (model.TransportSystem):</strong>  the model in which the agent is situated.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">unique_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">TransportSystem</span>,</span><span class=\"param\">\t<span class=\"n\">configuration</span><span class=\"p\">:</span> <span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span></span>)</span>"}, {"fullname": "agent.Vehicle.pos", "modulename": "agent", "qualname": "Vehicle.pos", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Tuple[int, int]"}, {"fullname": "agent.Vehicle.capacity", "modulename": "agent", "qualname": "Vehicle.capacity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agent.Vehicle.energy_level", "modulename": "agent", "qualname": "Vehicle.energy_level", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agent.Vehicle.heading", "modulename": "agent", "qualname": "Vehicle.heading", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "agent.Vehicle.create_plan", "modulename": "agent", "qualname": "Vehicle.create_plan", "kind": "function", "doc": "<p>The vehicle creates a plan, which consists of randomly moving to one the neighbours in the road network.\nOccasionally, it chooses instead to find a parking.\nWhen energy level is low, it searches for an available charging point and charges energy there.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "capabilities", "modulename": "capabilities", "kind": "module", "doc": "<p>Classes that define capabilities of agents.</p>\n"}, {"fullname": "capabilities.MoveCapability", "modulename": "capabilities", "qualname": "MoveCapability", "kind": "class", "doc": "<p>A generic capability, serving as a base class for specific capabilities.</p>\n", "bases": "sos_core.Capability"}, {"fullname": "capabilities.MoveCapability.__init__", "modulename": "capabilities", "qualname": "MoveCapability.__init__", "kind": "function", "doc": "<p>Defines the capability of an agent to move to a new position.\nThe capability can be given to an agent which has a pos attribute and has a model with a space containing a road network</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>agent (mesa.Agent):</strong>  the agent who should be given this capability.</li>\n<li><strong>new_pos (Position):</strong>  the new position in the space.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">mesa</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Agent</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "capabilities.MoveCapability.target", "modulename": "capabilities", "qualname": "MoveCapability.target", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "capabilities.MoveCapability.precondition", "modulename": "capabilities", "qualname": "MoveCapability.precondition", "kind": "function", "doc": "<p>Defines the preconditions to make a move:</p>\n\n<ul>\n<li>There is a road to the new node from the current node.</li>\n<li>There is no conflicting traffic.</li>\n<li>The agent has sufficient energy.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if and only if the move is possible.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "capabilities.MoveCapability.postcondition", "modulename": "capabilities", "qualname": "MoveCapability.postcondition", "kind": "function", "doc": "<p>The postcondition of a move is that the actual position is the same as the target.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if and only if the target has been reached.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "capabilities.MoveCapability.activate", "modulename": "capabilities", "qualname": "MoveCapability.activate", "kind": "function", "doc": "<p>Performs the move.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "capabilities.FindDestinationCapability", "modulename": "capabilities", "qualname": "FindDestinationCapability", "kind": "class", "doc": "<p>Defines the capability of an agent to find an available destination and move there.\nThe capability can be given to any agent that can move in a space containing a road network.\nIt can take an optional condition specifying what types of destinations are acceptable.</p>\n", "bases": "sos_core.Capability"}, {"fullname": "capabilities.FindDestinationCapability.__init__", "modulename": "capabilities", "qualname": "FindDestinationCapability.__init__", "kind": "function", "doc": "<p>Defines the capability of an agent to move to a new position.\nThe capability can be given to an agent which has a pos attribute and has a model with a space containing a road network</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>agent (mesa.Agent):</strong>  the agent who should be given this capability.</li>\n<li><strong>condition:</strong>  (Callable[Position, bool], optional): a condition to be fulfilled by the destination. Defaults to any destination.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">mesa</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Agent</span>,</span><span class=\"param\">\t<span class=\"n\">condition</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">FindDestinationCapability</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span></span>)</span>"}, {"fullname": "capabilities.FindDestinationCapability.condition", "modulename": "capabilities", "qualname": "FindDestinationCapability.condition", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "capabilities.FindDestinationCapability.precondition", "modulename": "capabilities", "qualname": "FindDestinationCapability.precondition", "kind": "function", "doc": "<p>Defines the preconditions to park. There are two alternatives:</p>\n\n<ol>\n<li>There is a free destination adjacent to the current position which fulfils the specified condition.</li>\n<li>The preconditions of the move capability are met. </li>\n</ol>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if and only if the agent can either park or move on.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "capabilities.FindDestinationCapability.postcondition", "modulename": "capabilities", "qualname": "FindDestinationCapability.postcondition", "kind": "function", "doc": "<p>The postcondition of a capability is that the position is a destination which fulfils the specified condition.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if and only if the current position is a destination which fulfils the specified condition.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "capabilities.FindDestinationCapability.activate", "modulename": "capabilities", "qualname": "FindDestinationCapability.activate", "kind": "function", "doc": "<p>Performs the parking or keep looking for another destination.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "capabilities.ChargeEnergyCapability", "modulename": "capabilities", "qualname": "ChargeEnergyCapability", "kind": "class", "doc": "<p>Defines the capability of an agent to charge energy.\nThis capability can be given to any agent which has the attributes energy_level and max_energy.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>agent (mesa.Agent):</strong>  the agent who should have this capability.</li>\n</ul>\n", "bases": "sos_core.Capability"}, {"fullname": "capabilities.ChargeEnergyCapability.precondition", "modulename": "capabilities", "qualname": "ChargeEnergyCapability.precondition", "kind": "function", "doc": "<p>The precondition is that the agent is at a charging point.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the capability can be used, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "capabilities.ChargeEnergyCapability.postcondition", "modulename": "capabilities", "qualname": "ChargeEnergyCapability.postcondition", "kind": "function", "doc": "<p>The postcondition is that the energy level has reached the maximum.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the capability has been fulfilled, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "capabilities.ChargeEnergyCapability.activate", "modulename": "capabilities", "qualname": "ChargeEnergyCapability.activate", "kind": "function", "doc": "<p>Charge energy.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "configuration", "modulename": "configuration", "kind": "module", "doc": "<p>Defines configuration handling mechanisms.</p>\n"}, {"fullname": "configuration.Configuration", "modulename": "configuration", "qualname": "Configuration", "kind": "class", "doc": "<p>Configurations are objects that contain all settings for generating a model and running the simulation.\nThe intention is that instead of passing individual parameters when creating model objects, the whole configuration is passed.\nThe parameters are grouped under different object classes, to which they apply.\nA configuration object can be initialized from command line arguments or a JSON string.</p>\n"}, {"fullname": "configuration.Configuration.__init__", "modulename": "configuration", "qualname": "Configuration.__init__", "kind": "function", "doc": "<p>Creates a configuration object with all parameters set to default values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "configuration.Configuration.params", "modulename": "configuration", "qualname": "Configuration.params", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;RoadNetworkGrid&#x27;: {&#x27;width&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 10, &#x27;flag&#x27;: &#x27;-x&#x27;, &#x27;help&#x27;: &#x27;number of grid cells in x dimension&#x27;}, &#x27;height&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 10, &#x27;flag&#x27;: &#x27;-y&#x27;, &#x27;help&#x27;: &#x27;number of grid cells in y dimension&#x27;}, &#x27;road_density&#x27;: {&#x27;type&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;default&#x27;: 0.3, &#x27;flag&#x27;: &#x27;-rd&#x27;, &#x27;help&#x27;: &#x27;the proportion of the grid to be covered by roads&#x27;}, &#x27;destination_density&#x27;: {&#x27;type&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;default&#x27;: 0.3, &#x27;flag&#x27;: &#x27;-dd&#x27;, &#x27;help&#x27;: &#x27;probability of generating a destination in a position where it is possible&#x27;}, &#x27;charging_point_density&#x27;: {&#x27;type&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;default&#x27;: 0.3, &#x27;flag&#x27;: &#x27;-cpd&#x27;, &#x27;help&#x27;: &#x27;probability of a destination having a charging point&#x27;}}, &#x27;Vehicle&#x27;: {&#x27;max_load&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 3, &#x27;flag&#x27;: &#x27;-ml&#x27;, &#x27;help&#x27;: &#x27;maximum load of a vehicle&#x27;}, &#x27;max_energy&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 100, &#x27;flag&#x27;: &#x27;-me&#x27;, &#x27;help&#x27;: &#x27;maximum energy of a vehicle&#x27;}, &#x27;charging_speed&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 10, &#x27;flag&#x27;: &#x27;-cs&#x27;, &#x27;help&#x27;: &#x27;the charging speed of a vehicle&#x27;}, &#x27;parking_probability&#x27;: {&#x27;type&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;default&#x27;: 0.1, &#x27;flag&#x27;: &#x27;-pp&#x27;, &#x27;help&#x27;: &#x27;probability that a vehicle will start looking for a parking&#x27;}}, &#x27;TransportSystem&#x27;: {&#x27;num_agents&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 10, &#x27;flag&#x27;: &#x27;-N&#x27;, &#x27;help&#x27;: &#x27;number of vehicles&#x27;}, &#x27;random_seed&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 3578866197401306095, &#x27;flag&#x27;: &#x27;-r&#x27;, &#x27;help&#x27;: &#x27;seed for random number generator&#x27;}}}"}, {"fullname": "configuration.Configuration.parser", "modulename": "configuration", "qualname": "Configuration.parser", "kind": "variable", "doc": "<p></p>\n", "default_value": "ArgumentParser(prog=&#x27;SoSSIM&#x27;, usage=None, description=&#x27;A system-of-systems simulator for a transport system&#x27;, formatter_class=&lt;class &#x27;argparse.HelpFormatter&#x27;&gt;, conflict_handler=&#x27;error&#x27;, add_help=True)"}, {"fullname": "configuration.Configuration.data", "modulename": "configuration", "qualname": "Configuration.data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "configuration.Configuration.add_param", "modulename": "configuration", "qualname": "Configuration.add_param", "kind": "function", "doc": "<p>Adds a parameter to a class, with a type, default value, a command line argument flag, and a help string.\nThe current value is set to the default value.\nTypically, this method is called in conjunction with the definition of the class to which it applies.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>class_name (str):</strong>  the name of the class.</li>\n<li><strong>name (str):</strong>  the name of the parameter.</li>\n<li><strong>type (Any):</strong>  the type of the parameter.</li>\n<li><strong>default (Any):</strong>  the default value of the parameter.</li>\n<li><strong>flag (str):</strong>  a command line argument flag.</li>\n<li><strong>help (str):</strong>  a help string.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">class_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"nb\">type</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">default</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">flag</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">help</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "configuration.Configuration.set_param_value", "modulename": "configuration", "qualname": "Configuration.set_param_value", "kind": "function", "doc": "<p>Sets the value of a parameter of a certain class.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cls (str):</strong>  the class to which the parameter belongs.</li>\n<li><strong>name (str):</strong>  the name of the parameter.</li>\n<li><strong>value (Any):</strong>  the new value of the parameter.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"bp\">cls</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "configuration.Configuration.initialize", "modulename": "configuration", "qualname": "Configuration.initialize", "kind": "function", "doc": "<p>Initializes object attributes according to the configuration.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>obj (Any):</strong>  the object to be initialized.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "configuration.Configuration.parse_args", "modulename": "configuration", "qualname": "Configuration.parse_args", "kind": "function", "doc": "<p>Updates parameter values from the command line.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Any: the parsed command line arguments.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "configuration.Configuration.to_json", "modulename": "configuration", "qualname": "Configuration.to_json", "kind": "function", "doc": "<p>Generates a string containing the JSON representation of the configuration.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: a JSON representation of the configuration.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "configuration.Configuration.from_json", "modulename": "configuration", "qualname": "Configuration.from_json", "kind": "function", "doc": "<p>Updates the configuration with the values provided in the JSON formatted text.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  a JSON representation of a configuration.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "model", "modulename": "model", "kind": "module", "doc": "<p>Provides models for the SoSSim system-of-systems simulator.</p>\n"}, {"fullname": "model.TransportSystem", "modulename": "model", "qualname": "TransportSystem", "kind": "class", "doc": "<p>Base class for models.</p>\n", "bases": "mesa.model.Model, view.Viewable"}, {"fullname": "model.TransportSystem.__init__", "modulename": "model", "qualname": "TransportSystem.__init__", "kind": "function", "doc": "<p>Creates a transport system model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>configuration (Configuration):</strong>  the configuration of parameters from which the model is generated.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">configuration</span><span class=\"p\">:</span> <span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span></span>)</span>"}, {"fullname": "model.TransportSystem.schedule", "modulename": "model", "qualname": "TransportSystem.schedule", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "model.TransportSystem.space", "modulename": "model", "qualname": "TransportSystem.space", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "model.TransportSystem.step", "modulename": "model", "qualname": "TransportSystem.step", "kind": "function", "doc": "<p>Performs a simulation step and updates the views.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim", "modulename": "sossim", "kind": "module", "doc": "<p>Main file for the SoSSim system-of-systems simulator.\nIt imports the necessary modules and configures the simulation.\nIt can be ran in batch mode or in interactive mode in the browser using pyscript.</p>\n"}, {"fullname": "sossim.interactive_mode", "modulename": "sossim", "qualname": "interactive_mode", "kind": "function", "doc": "<p>Runs the simulator in interactive mode in the browser.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">configuration</span><span class=\"p\">:</span> <span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.batch_mode", "modulename": "sossim", "qualname": "batch_mode", "kind": "function", "doc": "<p>Runs the simulator in batch mode from command line.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">configuration</span><span class=\"p\">:</span> <span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sos_core", "modulename": "sos_core", "kind": "module", "doc": "<p>Provides abstract classes representing the core concepts of systems-of-systems.</p>\n"}, {"fullname": "sos_core.SoSAgent", "modulename": "sos_core", "qualname": "SoSAgent", "kind": "class", "doc": "<p>Base class for a model agent.</p>\n", "bases": "mesa.agent.Agent, view.Viewable"}, {"fullname": "sos_core.SoSAgent.__init__", "modulename": "sos_core", "qualname": "SoSAgent.__init__", "kind": "function", "doc": "<p>Creates a SoS agent in a simulation model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>unique_id (int):</strong>  the unique id of the agent.</li>\n<li><strong>model (mesa.Model):</strong>  the model in which the agent is situated.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">unique_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">mesa</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">Model</span></span>)</span>"}, {"fullname": "sos_core.SoSAgent.plan", "modulename": "sos_core", "qualname": "SoSAgent.plan", "kind": "variable", "doc": "<p></p>\n", "annotation": ": List[sos_core.Capability]"}, {"fullname": "sos_core.SoSAgent.create_plan", "modulename": "sos_core", "qualname": "SoSAgent.create_plan", "kind": "function", "doc": "<p>Creates a plan for the agent, consisting of a list of capability instances.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sos_core.SoSAgent.step", "modulename": "sos_core", "qualname": "SoSAgent.step", "kind": "function", "doc": "<p>The first part of a simulation round when using the Mesa simultaneous activation scheduler.\nIf the agent does not have a plan, it creates one.\nThen it checks that the preconditions of the first action in the plan are fulfilled.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sos_core.SoSAgent.advance", "modulename": "sos_core", "qualname": "SoSAgent.advance", "kind": "function", "doc": "<p>The second part of a simulation round when using the Mesa simultaneous activation scheduler.\nIf the precondition of the first action in the current plan was fullfilled, that action is now carried out.\nIf this leads to the action's postcondition being fulfilled, the action is removed from the plan.\nFinally, if the agent has a view, that view is updated.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sos_core.Capability", "modulename": "sos_core", "qualname": "Capability", "kind": "class", "doc": "<p>A generic capability, serving as a base class for specific capabilities.</p>\n"}, {"fullname": "sos_core.Capability.__init__", "modulename": "sos_core", "qualname": "Capability.__init__", "kind": "function", "doc": "<p>Creates the capability for a certain agent.\nSubclasses can add parameters for how to use a certain capability.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>agent (mesa.Agent):</strong>  the agent who should have this capability.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">sos_core</span><span class=\"o\">.</span><span class=\"n\">SoSAgent</span></span>)</span>"}, {"fullname": "sos_core.Capability.agent", "modulename": "sos_core", "qualname": "Capability.agent", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sos_core.Capability.precondition", "modulename": "sos_core", "qualname": "Capability.precondition", "kind": "function", "doc": "<p>Checks if the precondition for executing this capability is fulfilled.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the capability can be used, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sos_core.Capability.postcondition", "modulename": "sos_core", "qualname": "Capability.postcondition", "kind": "function", "doc": "<p>Checks if the postcondition for this capability is fulfilled.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the capability has been fulfilled, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sos_core.Capability.activate", "modulename": "sos_core", "qualname": "Capability.activate", "kind": "function", "doc": "<p>Carries out the capability.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "space", "modulename": "space", "kind": "module", "doc": "<p>Provides spaces for the SoSSim system-of-systems simulator.\nThe space is a grid rendered as a bidirectional graph, with nodes being grid cells and with edges between all adjacent grid cells.\nAttributes can be set on nodes and edges to represent roads, destinations, etc.</p>\n"}, {"fullname": "space.Node", "modulename": "space", "qualname": "Node", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Tuple[int, int]"}, {"fullname": "space.Edge", "modulename": "space", "qualname": "Edge", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Tuple[typing.Tuple[int, int], typing.Tuple[int, int]]"}, {"fullname": "space.Direction", "modulename": "space", "qualname": "Direction", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;class &#x27;int&#x27;&gt;"}, {"fullname": "space.RoadGridGraph", "modulename": "space", "qualname": "RoadGridGraph", "kind": "class", "doc": "<p>A directed graph representing a 2D grid where the edges are labelled by direction in degrees.\nRoads are represented by having the node and edge attribute \"road\" set to True.\nDestinations are represented by having the node attribute \"destination\" set to True.\nSome destinations can also have charging points.</p>\n", "bases": "networkx.classes.digraph.DiGraph"}, {"fullname": "space.RoadGridGraph.__init__", "modulename": "space", "qualname": "RoadGridGraph.__init__", "kind": "function", "doc": "<p>Creates the grid graph.\nTwo dictionaries are provided that give optional default attributes to nodes and edges.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>width (int):</strong>  the width of the grid.</li>\n<li><strong>height (int):</strong>  the height of the grid.</li>\n<li><strong>node_attrs (Dict[str, Any]):</strong>  attributes and values to be added to each node. Defaults to an empty dictionary.</li>\n<li><strong>edge_attrs (Dict[str, Any]):</strong>  attributes and values to be added to each edge. Defaults to an empty dictionary.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>nx.DiGraph: the resulting graph.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">width</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">node_attrs</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">edge_attrs</span><span class=\"p\">:</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{}</span></span>)</span>"}, {"fullname": "space.RoadGridGraph.add_road", "modulename": "space", "qualname": "RoadGridGraph.add_road", "kind": "function", "doc": "<p>Adds a road from the source node to the sink node.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  source node.</li>\n<li><strong>sink (Node):</strong>  sink node.</li>\n<li><strong>bidirectional (bool, optional):</strong>  if True, the road in opposite direction is also added. Defaults to False.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">sink</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">bidirectional</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "space.RoadGridGraph.add_roads", "modulename": "space", "qualname": "RoadGridGraph.add_roads", "kind": "function", "doc": "<p>Adds a sequence of roads to the network, starting in the provided node and going in the provided directions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node (Node):</strong>  the start node.</li>\n<li><strong>directions (List[Direction]):</strong>  a list containing directions in degrees.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">directions</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "space.RoadGridGraph.add_destination", "modulename": "space", "qualname": "RoadGridGraph.add_destination", "kind": "function", "doc": "<p>Adds a destination node, as a neighbor of the given node.\nRoads are added to and from the destination from the node.\nThe destination node is indicated as such using a node attribute.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node1 (Node):</strong>  the node to be connected to the destination.</li>\n<li><strong>node2 (Node):</strong>  the destination.</li>\n<li><strong>charging_point (bool, optional):</strong>  if True, the destination is a charging point. Defaults to False.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node1</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">node2</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">charging_point</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "space.RoadGridGraph.has_road_to", "modulename": "space", "qualname": "RoadGridGraph.has_road_to", "kind": "function", "doc": "<p>Returns True if and only if the graph has a road from the given node in the given direction.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  the source node.</li>\n<li><strong>direction (Direction):</strong>  the direction in degrees.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadGridGraph.is_road", "modulename": "space", "qualname": "RoadGridGraph.is_road", "kind": "function", "doc": "<p>Checks if a node or an edge is a road. If two nodes are given, it checks the edge, otherwise the node.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node1 (Node):</strong>  a node.</li>\n<li><strong>node2 (Optional[Node], optional):</strong>  a second node, if checking an edge. Defaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the node or edge is a road.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node1</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">node2</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadGridGraph.road_degree", "modulename": "space", "qualname": "RoadGridGraph.road_degree", "kind": "function", "doc": "<p>Returns the number of outgoing roads from a node.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node (Node):</strong>  the node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the number of outgoing roads.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.subnode", "modulename": "space", "qualname": "subnode", "kind": "function", "doc": "<p>Returns the detailed network subnode (i, j) of a coarse network node.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">j</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid", "modulename": "space", "qualname": "RoadNetworkGrid", "kind": "class", "doc": "<p>A mesa space consisting of a road network which is placed on a grid.\nThe road network is a networkx graph, where node names are tuples (x, y) referring to grid positions.\nSome nodes in the road networks can be destinations, where places of interest can be placed.</p>\n", "bases": "view.Viewable"}, {"fullname": "space.RoadNetworkGrid.__init__", "modulename": "space", "qualname": "RoadNetworkGrid.__init__", "kind": "function", "doc": "<p>Creates a grid of size (width, height), and adds a road network to it.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>configuration (Configuration):</strong>  the configuration of parameters from which the road network is generated.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">configuration</span><span class=\"p\">:</span> <span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span></span>)</span>"}, {"fullname": "space.RoadNetworkGrid.coarse_network", "modulename": "space", "qualname": "RoadNetworkGrid.coarse_network", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "space.RoadNetworkGrid.road_network", "modulename": "space", "qualname": "RoadNetworkGrid.road_network", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "space.RoadNetworkGrid.generate_roads", "modulename": "space", "qualname": "RoadNetworkGrid.generate_roads", "kind": "function", "doc": "<p>Generates the road network. This is a two step process.\nFirst, a coarse undirected network is generated, where each node corresponds to a grid cell.\nHeustistics are used to try to spread this network over the grid and have a balance between dense and sprawling roads.\nSecond, this network is expanded into a directed graph, containing separate roadways and roundabouts.\nThis is achieved by dividing each coarse network node / grid cell into 4 x 4 subnodes.\nThese are connected so that traffic in all directions become possible.\nIn the resulting directed network, each node has either one or two outgoing edges.\nThe network keeps track of what agents are currently in a node.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.priority_nodes", "modulename": "space", "qualname": "RoadNetworkGrid.priority_nodes", "kind": "function", "doc": "<p>Returns the nodes from which traffic has priority over from_node when going into to_node.\nThis is traffic coming from the left in a roundabout, and any traffic when leaving a parking.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>from_node (Node):</strong>  the node to be checked for priority.</li>\n<li><strong>to_node (Node):</strong>  the node to be checked for priority.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List[Node]: a list of nodes from which vehicles have priority.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">from_node</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">to_node</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.road_nodes", "modulename": "space", "qualname": "RoadNetworkGrid.road_nodes", "kind": "function", "doc": "<p>Returns a list of all nodes which are connected by roads.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List[Node]: the nodes connected by roads.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.road_edges", "modulename": "space", "qualname": "RoadNetworkGrid.road_edges", "kind": "function", "doc": "<p>Returns a list of all edges that are roads.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List[Node]: the nodes connected by roads.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.roads_from", "modulename": "space", "qualname": "RoadNetworkGrid.roads_from", "kind": "function", "doc": "<p>Returns a list of all nodes that can be reached by road from a given source node.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  the source node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List[Node]: a list of nodes reachable by road.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.roads_to", "modulename": "space", "qualname": "RoadNetworkGrid.roads_to", "kind": "function", "doc": "<p>Returns a list of all nodes that can reach the given sink node by road.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sink (Node):</strong>  the sink node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List[Node]: a list of nodes from which the sink node can be reached by road.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">sink</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.is_destination", "modulename": "space", "qualname": "RoadNetworkGrid.is_destination", "kind": "function", "doc": "<p>Checks if a node is a destination.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node (Node):</strong>  the node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the node is a destination.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.is_charging_point", "modulename": "space", "qualname": "RoadNetworkGrid.is_charging_point", "kind": "function", "doc": "<p>Checks if a node is a charging point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node (Node):</strong>  the node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the node is a charging point.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.edge_direction", "modulename": "space", "qualname": "RoadNetworkGrid.edge_direction", "kind": "function", "doc": "<p>Returns the direction of the edge going from source to sink.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  source node.</li>\n<li><strong>sink (Node):</strong>  sink node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Direction: the direction in degrees.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">sink</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.has_road_to", "modulename": "space", "qualname": "RoadNetworkGrid.has_road_to", "kind": "function", "doc": "<p>Calls the method with the same name on self.road_network.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.is_road", "modulename": "space", "qualname": "RoadNetworkGrid.is_road", "kind": "function", "doc": "<p>Calls the method with the same name on self.road_network.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node1</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">node2</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.place_agent", "modulename": "space", "qualname": "RoadNetworkGrid.place_agent", "kind": "function", "doc": "<p>Place an agent in a node.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">mesa</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Agent</span>, </span><span class=\"param\"><span class=\"n\">node_id</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.get_neighborhood", "modulename": "space", "qualname": "RoadNetworkGrid.get_neighborhood", "kind": "function", "doc": "<p>Get all adjacent nodes within a certain radius</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node_id</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">include_center</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.get_neighbors", "modulename": "space", "qualname": "RoadNetworkGrid.get_neighbors", "kind": "function", "doc": "<p>Get all agents in adjacent nodes.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node_id</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">include_center</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">mesa</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Agent</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.move_agent", "modulename": "space", "qualname": "RoadNetworkGrid.move_agent", "kind": "function", "doc": "<p>Move an agent from its current node to a new node.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">mesa</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Agent</span>, </span><span class=\"param\"><span class=\"n\">node_id</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.remove_agent", "modulename": "space", "qualname": "RoadNetworkGrid.remove_agent", "kind": "function", "doc": "<p>Remove the agent from the network and set its pos attribute to None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">mesa</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Agent</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.is_cell_empty", "modulename": "space", "qualname": "RoadNetworkGrid.is_cell_empty", "kind": "function", "doc": "<p>Returns a bool of the contents of a cell.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node_id</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.get_cell_list_contents", "modulename": "space", "qualname": "RoadNetworkGrid.get_cell_list_contents", "kind": "function", "doc": "<p>Returns a list of the agents contained in the nodes identified\nin <code>cell_list</code>; nodes with empty content are excluded.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cell_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">mesa</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Agent</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.get_all_cell_contents", "modulename": "space", "qualname": "RoadNetworkGrid.get_all_cell_contents", "kind": "function", "doc": "<p>Returns a list of all the agents in the network.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">mesa</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Agent</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "space.RoadNetworkGrid.iter_cell_list_contents", "modulename": "space", "qualname": "RoadNetworkGrid.iter_cell_list_contents", "kind": "function", "doc": "<p>Returns an iterator of the agents contained in the nodes identified\nin <code>cell_list</code>; nodes with empty content are excluded.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cell_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterator</span><span class=\"p\">[</span><span class=\"n\">mesa</span><span class=\"o\">.</span><span class=\"n\">agent</span><span class=\"o\">.</span><span class=\"n\">Agent</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "view", "modulename": "view", "kind": "module", "doc": "<p>Module containing functionality for attaching views to model classes.</p>\n"}, {"fullname": "view.View", "modulename": "view", "qualname": "View", "kind": "class", "doc": "<p>Base class for views.</p>\n"}, {"fullname": "view.View.update", "modulename": "view", "qualname": "View.update", "kind": "function", "doc": "<p>Updates the view. This is an abstract function that is redefined in subclasses.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>viewable (Viewable):</strong>  the viewable on which the update should be based.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">viewable</span><span class=\"p\">:</span> <span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">Viewable</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "view.Viewable", "modulename": "view", "qualname": "Viewable", "kind": "class", "doc": "<p>A mixin for objects to which a view can be attached. It adds the methods add_view and update_views.</p>\n"}, {"fullname": "view.Viewable.add_view", "modulename": "view", "qualname": "Viewable.add_view", "kind": "function", "doc": "<p>Adds a view to the viewable element.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>view (Any):</strong>  the view.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">view</span><span class=\"p\">:</span> <span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">View</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "view.Viewable.get_views", "modulename": "view", "qualname": "Viewable.get_views", "kind": "function", "doc": "<p>Returns the list of views attached to the viewable object.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List[View]: the views.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">View</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "view.Viewable.update_views", "modulename": "view", "qualname": "Viewable.update_views", "kind": "function", "doc": "<p>Updates the views.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "view.Viewable.clear_views", "modulename": "view", "qualname": "Viewable.clear_views", "kind": "function", "doc": "<p>Removes all views.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();