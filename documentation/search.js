window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "sossim.capabilities", "modulename": "sossim.capabilities", "kind": "module", "doc": "<p>Classes that define capabilities of agents.</p>\n\n<p>Partial UML class diagram:</p>\n\n<pre class=\"mermaid-pre\"><div class=\"mermaid\">classDiagram\n    `core.Capability` &lt;|-- FollowRoute\n    `core.Capability` &lt;|-- LoadCargo\n    `core.Capability` &lt;|-- UnloadCargo\n    `core.Capability` &lt;|-- ChargeEnergy\n</div></pre>\n"}, {"fullname": "sossim.capabilities.FollowRoute", "modulename": "sossim.capabilities", "qualname": "FollowRoute", "kind": "class", "doc": "<p>A generic capability, serving as a base class for specific capabilities.</p>\n", "bases": "sossim.core.Capability"}, {"fullname": "sossim.capabilities.FollowRoute.__init__", "modulename": "sossim.capabilities", "qualname": "FollowRoute.__init__", "kind": "function", "doc": "<p>Defines the capability of an agent to move to a new position along a route of nodes.\nThe capability can be given to an agent which has a pos attribute and has a model with a space containing a road network.\nIt is provided with a route_planner function, which when invoked generates a route starting from the current position.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>agent (core.Agent):</strong>  the agent who should be given this capability.</li>\n<li><strong>route_planner (Callable[[], list[Node]]):</strong>  a function that generates the route to be traversed in space.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span>,</span><span class=\"param\">\t<span class=\"n\">route_planner</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]]</span></span>)</span>"}, {"fullname": "sossim.capabilities.FollowRoute.route_planner", "modulename": "sossim.capabilities", "qualname": "FollowRoute.route_planner", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.capabilities.FollowRoute.route", "modulename": "sossim.capabilities", "qualname": "FollowRoute.route", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[sossim.space.Node]"}, {"fullname": "sossim.capabilities.FollowRoute.start", "modulename": "sossim.capabilities", "qualname": "FollowRoute.start", "kind": "function", "doc": "<p>Generates a route to be followed, from the agent's current position.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.FollowRoute.precondition", "modulename": "sossim.capabilities", "qualname": "FollowRoute.precondition", "kind": "function", "doc": "<p>Defines the preconditions to follow a route:</p>\n\n<ul>\n<li>There is a non-empty route.</li>\n<li>There is a road to the next node from the current node.</li>\n<li>There is no conflicting traffic.</li>\n<li>The agent has sufficient energy.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if and only if the move is possible.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.FollowRoute.act", "modulename": "sossim.capabilities", "qualname": "FollowRoute.act", "kind": "function", "doc": "<p>Performs a move to the next node in the route, and remove that node from the route.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.FollowRoute.postcondition", "modulename": "sossim.capabilities", "qualname": "FollowRoute.postcondition", "kind": "function", "doc": "<p>The postcondition of a move is that the route is empty.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if and only if the final position of the route has been reached, meaning that the route is empty.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.FollowRoute.next_pos", "modulename": "sossim.capabilities", "qualname": "FollowRoute.next_pos", "kind": "function", "doc": "<p>Returns the first position of the route, if there is a route, and otherwise the current agent position.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple[int, int]: the intended next position.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.LoadCargo", "modulename": "sossim.capabilities", "qualname": "LoadCargo", "kind": "class", "doc": "<p>A generic capability, serving as a base class for specific capabilities.</p>\n", "bases": "sossim.core.Capability"}, {"fullname": "sossim.capabilities.LoadCargo.__init__", "modulename": "sossim.capabilities", "qualname": "LoadCargo.__init__", "kind": "function", "doc": "<p>Defines the capability of an agent to load a cargo.\nThe capability can be given to an agent which has a pos attribute and a max_load attribute.\nThe entity constituting the cargo should also have a position and a weight.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>agent (core.Agent):</strong>  the agent who should be given this capability.</li>\n<li><strong>cargo (core.Entity):</strong>  the cargo.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span>, </span><span class=\"param\"><span class=\"n\">cargo</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Entity</span></span>)</span>"}, {"fullname": "sossim.capabilities.LoadCargo.cargo", "modulename": "sossim.capabilities", "qualname": "LoadCargo.cargo", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.capabilities.LoadCargo.precondition", "modulename": "sossim.capabilities", "qualname": "LoadCargo.precondition", "kind": "function", "doc": "<p>Defines the preconditions to load a cargo:</p>\n\n<ul>\n<li>The cargo should be in the same position as the agent </li>\n<li>The cargo should not not already be loaded.</li>\n<li>The weight of the cargo should be less than the remaining load capacity of the agent.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if and only if loading the cargo is possible.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.LoadCargo.act", "modulename": "sossim.capabilities", "qualname": "LoadCargo.act", "kind": "function", "doc": "<p>Performs the loading.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.LoadCargo.postcondition", "modulename": "sossim.capabilities", "qualname": "LoadCargo.postcondition", "kind": "function", "doc": "<p>The postcondition of loading a cargo is that the agent is now the carrier of the cargo.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if and only if the cargo has been loaded.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.UnloadCargo", "modulename": "sossim.capabilities", "qualname": "UnloadCargo", "kind": "class", "doc": "<p>A generic capability, serving as a base class for specific capabilities.</p>\n", "bases": "sossim.core.Capability"}, {"fullname": "sossim.capabilities.UnloadCargo.__init__", "modulename": "sossim.capabilities", "qualname": "UnloadCargo.__init__", "kind": "function", "doc": "<p>Defines the capability of an agent to unload a cargo.\nThe capability can be given to an agent which can carry a cargo.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>agent (core.Agent):</strong>  the agent who should be given this capability.</li>\n<li><strong>cargo (core.Entity):</strong>  the cargo.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span>, </span><span class=\"param\"><span class=\"n\">cargo</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Entity</span></span>)</span>"}, {"fullname": "sossim.capabilities.UnloadCargo.cargo", "modulename": "sossim.capabilities", "qualname": "UnloadCargo.cargo", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.capabilities.UnloadCargo.precondition", "modulename": "sossim.capabilities", "qualname": "UnloadCargo.precondition", "kind": "function", "doc": "<p>Defines the preconditions to load a cargo:</p>\n\n<ul>\n<li>The agent is carrying the cargo.</li>\n<li>The current position is a destination.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if and only if unloading the cargo is possible.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.UnloadCargo.act", "modulename": "sossim.capabilities", "qualname": "UnloadCargo.act", "kind": "function", "doc": "<p>Performs the unloading.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.UnloadCargo.postcondition", "modulename": "sossim.capabilities", "qualname": "UnloadCargo.postcondition", "kind": "function", "doc": "<p>The postcondition of unloading a cargo is that the cargo is not carried by the agent.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if and only if the cargo has been loaded.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.ChargeEnergy", "modulename": "sossim.capabilities", "qualname": "ChargeEnergy", "kind": "class", "doc": "<p>Defines the capability of an agent to charge energy.\nThis capability can be given to any agent which has the attributes energy_level and max_energy.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>agent (core.Agent):</strong>  the agent who should have this capability.</li>\n</ul>\n", "bases": "sossim.core.Capability"}, {"fullname": "sossim.capabilities.ChargeEnergy.precondition", "modulename": "sossim.capabilities", "qualname": "ChargeEnergy.precondition", "kind": "function", "doc": "<p>The precondition is that the agent is at a charging point.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the capability can be used, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.ChargeEnergy.act", "modulename": "sossim.capabilities", "qualname": "ChargeEnergy.act", "kind": "function", "doc": "<p>Charge energy.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.capabilities.ChargeEnergy.postcondition", "modulename": "sossim.capabilities", "qualname": "ChargeEnergy.postcondition", "kind": "function", "doc": "<p>The postcondition is that the energy level has reached the maximum.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the capability has been fulfilled, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.configuration", "modulename": "sossim.configuration", "kind": "module", "doc": "<p>Defines a generic configuration handling mechanisms.\nThis allows all configuration parameters to be handled in a single object.\nThat object can be passed around to all configurable classes, allowing them to extract whatever information they need.\nA typical usage is as follows:</p>\n\n<pre><code>    from configuration import Configuration, configurable\n    from typing import Annotated\n\n    @configurable\n    class C:\n        param: Annotated[int, \"Param\", \"some help string\"] = 3\n\n        def __init__(self, configuration: Configuration):\n            configuration.initialize(self)\n\n    configuration = Configuration()\n    obj = C(configuration)\n    obj.p  # Returns 3\n</code></pre>\n\n<p>Here, the @configurable decorater informs that this is a class that can take configuration parameters.\nThe type annotated variable param specifies that this is a configuration parameter, with a help string and a default value of 3.\nIt is given a command line argument --param <value>. \nThe help string is shown when printing the help information for the command line.\nIt can also be used as tooltips in a user interface.</p>\n"}, {"fullname": "sossim.configuration.configurable", "modulename": "sossim.configuration", "qualname": "configurable", "kind": "function", "doc": "<p>A class decorator that processes Param declarations within the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span><span class=\"p\">:</span> <span class=\"nb\">type</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">type</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.configuration.Configuration", "modulename": "sossim.configuration", "qualname": "Configuration", "kind": "class", "doc": "<p>Configurations are objects that contain all settings for generating a model and running the simulation.\nThe intention is that instead of passing individual parameters when creating model objects, the whole configuration is passed.\nThe parameters are grouped under different object classes, to which they apply.\nA configuration object can be initialized from command line arguments or from a JSON string.</p>\n"}, {"fullname": "sossim.configuration.Configuration.__init__", "modulename": "sossim.configuration", "qualname": "Configuration.__init__", "kind": "function", "doc": "<p>Creates a configuration object with all parameters set to default values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "sossim.configuration.Configuration.params", "modulename": "sossim.configuration", "qualname": "Configuration.params", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict[str, dict[str, dict[str, typing.Any]]]", "default_value": "{&#x27;RoadNetworkGrid&#x27;: {&#x27;width&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 10, &#x27;help&#x27;: &#x27;number of grid cells in x dimension&#x27;}, &#x27;height&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 10, &#x27;help&#x27;: &#x27;number of grid cells in y dimension&#x27;}, &#x27;road_density&#x27;: {&#x27;type&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;default&#x27;: 0.3, &#x27;help&#x27;: &#x27;the proportion of the grid to be covered by roads&#x27;}, &#x27;destination_density&#x27;: {&#x27;type&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;default&#x27;: 0.3, &#x27;help&#x27;: &#x27;probability of generating a destination in a position where it is possible&#x27;}, &#x27;charging_point_density&#x27;: {&#x27;type&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;default&#x27;: 0.3, &#x27;help&#x27;: &#x27;probability of a destination having a charging point&#x27;}}, &#x27;Vehicle&#x27;: {&#x27;max_load&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 3, &#x27;help&#x27;: &#x27;maximum load of a vehicle&#x27;}, &#x27;max_energy&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 100, &#x27;help&#x27;: &#x27;maximum energy of a vehicle&#x27;}, &#x27;charging_speed&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 10, &#x27;help&#x27;: &#x27;the charging speed of a vehicle&#x27;}, &#x27;perception_range&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 2, &#x27;help&#x27;: &#x27;the perception range of the vehicle&#x27;}}, &#x27;Cargo&#x27;: {&#x27;max_cargo_weight&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 3, &#x27;help&#x27;: &#x27;The maximum weight of a cargo&#x27;}}, &#x27;TransportSystem&#x27;: {&#x27;num_vehicles&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 10, &#x27;help&#x27;: &#x27;number of vehicles&#x27;}, &#x27;num_cargos&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: 10, &#x27;help&#x27;: &#x27;number of cargos&#x27;}, &#x27;random_seed&#x27;: {&#x27;type&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;default&#x27;: -1, &#x27;help&#x27;: &#x27;seed for random number generator (use -1 to initialize from system time)&#x27;}, &#x27;collect_data&#x27;: {&#x27;type&#x27;: &lt;class &#x27;bool&#x27;&gt;, &#x27;default&#x27;: True, &#x27;help&#x27;: &#x27;enable data collection of state variables&#x27;}}}"}, {"fullname": "sossim.configuration.Configuration.parser", "modulename": "sossim.configuration", "qualname": "Configuration.parser", "kind": "variable", "doc": "<p></p>\n", "default_value": "ArgumentParser(prog=&#x27;build.py&#x27;, usage=None, description=None, formatter_class=&lt;class &#x27;argparse.HelpFormatter&#x27;&gt;, conflict_handler=&#x27;error&#x27;, add_help=True)"}, {"fullname": "sossim.configuration.Configuration.data", "modulename": "sossim.configuration", "qualname": "Configuration.data", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.configuration.Configuration.add_param", "modulename": "sossim.configuration", "qualname": "Configuration.add_param", "kind": "function", "doc": "<p>Adds a parameter to a class, with a type, default value, and a help string.\nThe current value is set to the default value.\nTypically, this method is called in conjunction with the definition of the class to which it applies.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>class_name (str):</strong>  the name of the class.</li>\n<li><strong>name (str):</strong>  the name of the parameter.</li>\n<li><strong>type (Any):</strong>  the type of the parameter.</li>\n<li><strong>default (Any):</strong>  the default value of the parameter.</li>\n<li><strong>help (str):</strong>  a help string.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">class_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"nb\">type</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">default</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">help</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.configuration.Configuration.set_param_value", "modulename": "sossim.configuration", "qualname": "Configuration.set_param_value", "kind": "function", "doc": "<p>Sets the value of a parameter of a certain class.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cls (str):</strong>  the class to which the parameter belongs.</li>\n<li><strong>name (str):</strong>  the name of the parameter.</li>\n<li><strong>value (Any):</strong>  the new value of the parameter.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"bp\">cls</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.configuration.Configuration.initialize", "modulename": "sossim.configuration", "qualname": "Configuration.initialize", "kind": "function", "doc": "<p>Initializes object attributes according to the configuration.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>obj (Any):</strong>  the object to be initialized.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.configuration.Configuration.parse_args", "modulename": "sossim.configuration", "qualname": "Configuration.parse_args", "kind": "function", "doc": "<p>Updates parameter values from the command line.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Any: the parsed command line arguments.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Any</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.configuration.Configuration.to_json", "modulename": "sossim.configuration", "qualname": "Configuration.to_json", "kind": "function", "doc": "<p>Generates a string containing the JSON representation of the configuration.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: a JSON representation of the configuration.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.configuration.Configuration.from_json", "modulename": "sossim.configuration", "qualname": "Configuration.from_json", "kind": "function", "doc": "<p>Updates the configuration with the values provided in the JSON formatted text.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  a JSON representation of a configuration.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core", "modulename": "sossim.core", "kind": "module", "doc": "<p>Provides abstract classes representing the core concepts of systems-of-systems.</p>\n\n<p>Partial UML class diagram:</p>\n\n<pre class=\"mermaid-pre\"><div class=\"mermaid\">classDiagram\n    `mesa.Model` &lt;|-- Model\n    `view.Viewable` &lt;|-- Model\n    `view.Viewable` &lt;|-- Space\n\n    Model: agents()\n    Model: agent(id)\n    Model: time()\n\n    class WorldModel\n    WorldModel --&gt; Space: space\n    WorldModel --&gt; Agent: agent\n    WorldModel: perceive()\n\n    `mesa.Agent`&lt;|-- Entity\n    `view.Viewable` &lt;|-- Entity\n    Entity: pos\n    Entity: can_coexist(other)\n    Entity: observe()\n    Entity: orient()\n    Entity: decide()\n    Entity: act()\n\n    Entity &lt;|-- Agent\n    Agent --&gt; WorldModel: world_model\n    Agent: update_plan()\n    Agent: next_pos()\n\n    Capability --&gt; Agent: agent\n    Capability: start()\n    Capability: precondition()\n    Capability: postcondition()\n    Capability: next_pos()\n</div></pre>\n"}, {"fullname": "sossim.core.Model", "modulename": "sossim.core", "qualname": "Model", "kind": "class", "doc": "<p>A comman base class for SoS models.</p>\n", "bases": "mesa.model.Model, sossim.view.Viewable"}, {"fullname": "sossim.core.Model.__init__", "modulename": "sossim.core", "qualname": "Model.__init__", "kind": "function", "doc": "<p>Create a new model object and instantiate its RNG automatically.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"n\">Any</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span>)</span>"}, {"fullname": "sossim.core.Model.schedule", "modulename": "sossim.core", "qualname": "Model.schedule", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.core.Model.agents", "modulename": "sossim.core", "qualname": "Model.agents", "kind": "function", "doc": "<p>Returns the agents in the model.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Agent]: the agents</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Model.agent", "modulename": "sossim.core", "qualname": "Model.agent", "kind": "function", "doc": "<p>Returns the agent with the given id. \nIf the agent with that id does not exist, a KeyError exception is raised.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>id (int):</strong>  the agent of the requested agent.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Agent: the requested agent.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Model.time", "modulename": "sossim.core", "qualname": "Model.time", "kind": "function", "doc": "<p>Returns the current time of the simulation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Float: the time.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Space", "modulename": "sossim.core", "qualname": "Space", "kind": "class", "doc": "<p>A comman base class for SoS spaces.</p>\n", "bases": "sossim.view.Viewable"}, {"fullname": "sossim.core.Space.random", "modulename": "sossim.core", "qualname": "Space.random", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.core.WorldModel", "modulename": "sossim.core", "qualname": "WorldModel", "kind": "class", "doc": "<p>A common base class for SoS world models.\nThe world model is an internal, cognitive representation of information about the world.\nIt is updated by the agent's perception, and used for reasoning about e.g. planned actions.</p>\n"}, {"fullname": "sossim.core.WorldModel.__init__", "modulename": "sossim.core", "qualname": "WorldModel.__init__", "kind": "function", "doc": "<p>Creates a world model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>model (Model):</strong>  the simulation's representation of the real world.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span></span>)</span>"}, {"fullname": "sossim.core.WorldModel.agent", "modulename": "sossim.core", "qualname": "WorldModel.agent", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.core.WorldModel.space", "modulename": "sossim.core", "qualname": "WorldModel.space", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.core.WorldModel.plan", "modulename": "sossim.core", "qualname": "WorldModel.plan", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[sossim.core.Capability]"}, {"fullname": "sossim.core.WorldModel.perceive", "modulename": "sossim.core", "qualname": "WorldModel.perceive", "kind": "function", "doc": "<p>Updates the perception of the world as represented in this world model.\nRedefined in subclasses.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Entity", "modulename": "sossim.core", "qualname": "Entity", "kind": "class", "doc": "<p>A common abstract baseclass for entities within a SoS.\nAll entities are treated as agents, but not all of them have behavior.\nThis means also that they can be placed on the map, and have a unique id, which is automatically generated.</p>\n", "bases": "mesa.agent.Agent, sossim.view.Viewable"}, {"fullname": "sossim.core.Entity.__init__", "modulename": "sossim.core", "qualname": "Entity.__init__", "kind": "function", "doc": "<p>Create a new agent.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>unique_id (int):</strong>  A unique numeric identified for the agent</li>\n<li><strong>model:</strong>  (Model): Instance of the model that contains the agent</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Model</span></span>)</span>"}, {"fullname": "sossim.core.Entity.pos", "modulename": "sossim.core", "qualname": "Entity.pos", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[tuple[int, int], &#x27;State&#x27;]"}, {"fullname": "sossim.core.Entity.can_coexist", "modulename": "sossim.core", "qualname": "Entity.can_coexist", "kind": "function", "doc": "<p>Returns True if this entity can coexist in the same cell with the other entity.\nDefault is that all entities can coexist, but this can be refined for specific subclasses.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>other (SoSEntity):</strong>  another entity.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if coexistance is possible.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">Self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Entity.observe", "modulename": "sossim.core", "qualname": "Entity.observe", "kind": "function", "doc": "<p>Observe stage of the OODA loop used by the simulation scheduler.\nDefault behavior is to do nothing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Entity.orient", "modulename": "sossim.core", "qualname": "Entity.orient", "kind": "function", "doc": "<p>Orient stage of the OODA loop used by the simulation scheduler.\nDefault behavior is to do nothing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Entity.decide", "modulename": "sossim.core", "qualname": "Entity.decide", "kind": "function", "doc": "<p>Decide stage of the OODA loop used by the simulation scheduler.\nDefault behavior is to do nothing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Entity.act", "modulename": "sossim.core", "qualname": "Entity.act", "kind": "function", "doc": "<p>Act stage of the OODA loop used by the simulation scheduler.\nDefault behavior is to just update the views.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Agent", "modulename": "sossim.core", "qualname": "Agent", "kind": "class", "doc": "<p>A common abstract baseclass for entities within a SoS.\nAll entities are treated as agents, but not all of them have behavior.\nThis means also that they can be placed on the map, and have a unique id, which is automatically generated.</p>\n", "bases": "Entity"}, {"fullname": "sossim.core.Agent.__init__", "modulename": "sossim.core", "qualname": "Agent.__init__", "kind": "function", "doc": "<p>Creates a SoS agent in a simulation model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>unique_id (int):</strong>  the unique id of the agent.</li>\n<li><strong>model (Model):</strong>  the model in which the agent is situated.</li>\n<li><strong>world_model (WorldModel):</strong>  the world model of the agent.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Model</span>, </span><span class=\"param\"><span class=\"n\">world_model</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">WorldModel</span></span>)</span>"}, {"fullname": "sossim.core.Agent.world_model", "modulename": "sossim.core", "qualname": "Agent.world_model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.core.Agent.update_plan", "modulename": "sossim.core", "qualname": "Agent.update_plan", "kind": "function", "doc": "<p>Update the plan for the agent, consisting of a list of capability instances.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Agent.observe", "modulename": "sossim.core", "qualname": "Agent.observe", "kind": "function", "doc": "<p>Observe stage of the OODA loop used by the simulation scheduler.\nIt updates the world model through perception.\nIf the agent has a plan, and the first step in that plan is completed, it skips to the next step.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Agent.orient", "modulename": "sossim.core", "qualname": "Agent.orient", "kind": "function", "doc": "<p>Orient stage of the OODA loop used by the simulation scheduler.\nIt updates the agent's plan.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Agent.decide", "modulename": "sossim.core", "qualname": "Agent.decide", "kind": "function", "doc": "<p>Decide stage of the OODA loop used by the simulation scheduler.\nIt checks if the preconditions of the first action in the plan are fulfilled.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Agent.act", "modulename": "sossim.core", "qualname": "Agent.act", "kind": "function", "doc": "<p>Act stage of the OODA loop used by the simulation scheduler.\nIf the precondition of the first action in the current plan was fullfilled, that action is now carried out.\nThen, any further actions specified in the superclass are carried out.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Agent.next_pos", "modulename": "sossim.core", "qualname": "Agent.next_pos", "kind": "function", "doc": "<p>Returns the intended next position of the agent, based on its plan. \nIf the agent has a plan, the intended next position of the first capability of the plan is returned.\nIf there is no plan, None is returned.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[int, int] | None: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Capability", "modulename": "sossim.core", "qualname": "Capability", "kind": "class", "doc": "<p>A generic capability, serving as a base class for specific capabilities.</p>\n"}, {"fullname": "sossim.core.Capability.__init__", "modulename": "sossim.core", "qualname": "Capability.__init__", "kind": "function", "doc": "<p>Creates the capability for a certain agent.\nSubclasses can add parameters for how to use a certain capability.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>agent (Agent):</strong>  the agent who should have this capability.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span></span>)</span>"}, {"fullname": "sossim.core.Capability.random", "modulename": "sossim.core", "qualname": "Capability.random", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.core.Capability.agent", "modulename": "sossim.core", "qualname": "Capability.agent", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.core.Capability.started", "modulename": "sossim.core", "qualname": "Capability.started", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.core.Capability.start", "modulename": "sossim.core", "qualname": "Capability.start", "kind": "function", "doc": "<p>Starts the application of the capability.\nThis is useful for capabilities that may be started from a different state than when they were put into a plan.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Capability.precondition", "modulename": "sossim.core", "qualname": "Capability.precondition", "kind": "function", "doc": "<p>Checks if the precondition for executing this capability is fulfilled.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the capability can be used, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Capability.act", "modulename": "sossim.core", "qualname": "Capability.act", "kind": "function", "doc": "<p>Carries out the capability during one time step.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Capability.postcondition", "modulename": "sossim.core", "qualname": "Capability.postcondition", "kind": "function", "doc": "<p>Checks if the postcondition for this capability is fulfilled.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the capability has been fulfilled, False otherwise</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.core.Capability.next_pos", "modulename": "sossim.core", "qualname": "Capability.next_pos", "kind": "function", "doc": "<p>Returns the intended next position of the agent, if this capability were to be activated.\nNote that this is not necessarily the position in the next time step, since preconditions may inhibit the move.\nIn case of an inhibited move, next_pos may change in the next time step, if replanning occurs.\nDefault behavior is to return the current agent position, i.e. the capability does not move the agent.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple[int, int]: the intended next position.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.datacollection", "modulename": "sossim.datacollection", "kind": "module", "doc": "<p>Datacollection for the SoSSim system-of-systems simulator.\nIt defines a subclass of mesa's data collector, that collects data on all defined state variables.</p>\n"}, {"fullname": "sossim.datacollection.StateDataCollector", "modulename": "sossim.datacollection", "qualname": "StateDataCollector", "kind": "class", "doc": "<p>Class for collecting data generated by a Mesa model.</p>\n\n<p>A DataCollector is instantiated with dictionaries of names of model- and\nagent-level variables to collect, associated with attribute names or\nfunctions which actually collect them. When the collect(...) method is\ncalled, it collects these attributes and executes these functions one by\none and stores the results.</p>\n", "bases": "mesa.datacollection.DataCollector"}, {"fullname": "sossim.datacollection.StateDataCollector.__init__", "modulename": "sossim.datacollection", "qualname": "StateDataCollector.__init__", "kind": "function", "doc": "<p>Creates a data collector that collects all state variables defined in the system.\nSeparate tables are provided for each class that contains state variables.\nEach table has one column for each state variable, and also one column for the agent unique id.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "sossim.datacollection.StateDataCollector.collect", "modulename": "sossim.datacollection", "qualname": "StateDataCollector.collect", "kind": "function", "doc": "<p>Collects all data for the given model object at the current time.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>model (core.Model):</strong>  the model for which data is to be collected.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Model</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.datacollection.StateDataCollector.has_rows", "modulename": "sossim.datacollection", "qualname": "StateDataCollector.has_rows", "kind": "function", "doc": "<p>Returns True if and only if the table with the given name contains any rows.\nIf no table name is given, it returns True if any of the table contains a row.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>table_name (str):</strong>  the name of the table.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if and only if the table (or any of the table) contains any rows.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">table_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.dynamics", "modulename": "sossim.dynamics", "kind": "module", "doc": "<p>Provides support for describing dynamics of entities.\nThis includes a possibility to declare state variables of classes.\nA typical usage would be:</p>\n\n<pre><code>    class C:\n        x: Annotated[int, \"State\"]\n        ...\n</code></pre>\n\n<p>Then, <code>state_variables(C)</code> returns a list of all the state variable names declared in this class and its superclasses.</p>\n"}, {"fullname": "sossim.dynamics.state_variables", "modulename": "sossim.dynamics", "qualname": "state_variables", "kind": "function", "doc": "<p>Returns a list of the names of all variables of a class that have been declared as Annotated[T, \"State\"].</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cls (type):</strong>  the class.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[str]: the list of state variables.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span><span class=\"p\">:</span> <span class=\"nb\">type</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.dynamics.all_state_variables", "modulename": "sossim.dynamics", "qualname": "all_state_variables", "kind": "function", "doc": "<p>Returns all state variables defined in any class that is a subclass of cls.\nThe result is a dict, that maps each class name to a list of state variables.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, list[str]]: the state variables for each class.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span><span class=\"p\">:</span> <span class=\"nb\">type</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities", "modulename": "sossim.entities", "kind": "module", "doc": "<p>Provides concrete agents and other entities.</p>\n\n<p>Partial UML class diagram:</p>\n\n<pre class=\"mermaid-pre\"><div class=\"mermaid\">classDiagram\n    Agent --&gt; WorldModel: world_model\n\n    Navigator --&gt; `space.RoadNetworkGrid`: space\n    Navigator: shortest_path(source, target)\n    Navigator: path_to_nearest(source, targets)\n    Navigator: path_to_nearest_charging_point(source)\n\n    `core.WorldModel` &lt;|-- VehicleWorldModel\n    VehicleWorldModel --&gt; Vehicle: agent\n\n    `core.Agent` &lt;|-- Vehicle\n    Vehicle --&gt; Navigator: navigator\n    Vehicle --&gt; `space.RoadNetworkGrid`: space\n    Vehicle --&gt; VehicleWorldModel: world_model\n    Vehicle: energy_level\n    Vehicle: heading\n    Vehicle: load_cargo(cargo)\n    Vehicle: unload_cargo(cargo)\n\n    `core.Entity`&lt;|-- Cargo\n    Vehicle --&gt; \"*\" Cargo: cargos\n    Cargo --&gt; \"0..1\" Vehicle : carrier\n    Cargo: weight\n    Cargo: destination\n    Cargo: load_onto(carrier)\n    Cargo: unload()\n</div></pre>\n"}, {"fullname": "sossim.entities.Navigator", "modulename": "sossim.entities", "qualname": "Navigator", "kind": "class", "doc": "<p>A navigation system that can be used to find routes between destinations.</p>\n"}, {"fullname": "sossim.entities.Navigator.__init__", "modulename": "sossim.entities", "qualname": "Navigator.__init__", "kind": "function", "doc": "<p>Initializes the navigator based on the space it navigates in.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>space (RoadNetworkGrid):</strong>  the space to navigate in.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">space</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">RoadNetworkGrid</span></span>)</span>"}, {"fullname": "sossim.entities.Navigator.space", "modulename": "sossim.entities", "qualname": "Navigator.space", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.entities.Navigator.shortest_path", "modulename": "sossim.entities", "qualname": "Navigator.shortest_path", "kind": "function", "doc": "<p>Returns the shortest path from source to sink as a list of nodes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  the source node.</li>\n<li><strong>target (Node):</strong>  the target node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: the path.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Navigator.path_to_nearest", "modulename": "sossim.entities", "qualname": "Navigator.path_to_nearest", "kind": "function", "doc": "<p>Given a source node and a list of target nodes, return the path to the nearest of the targets.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  the source node.</li>\n<li><strong>targets (list[Node]):</strong>  the list of target nodes.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: the path to the nearest target node.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">targets</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Navigator.path_to_nearest_charging_point", "modulename": "sossim.entities", "qualname": "Navigator.path_to_nearest_charging_point", "kind": "function", "doc": "<p>Returns the path to the nearest charging point from a source node.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  the starting point.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: the path to the nearest charging point.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.VehicleWorldModel", "modulename": "sossim.entities", "qualname": "VehicleWorldModel", "kind": "class", "doc": "<p>The world model of a vehicle.</p>\n", "bases": "sossim.core.WorldModel"}, {"fullname": "sossim.entities.VehicleWorldModel.__init__", "modulename": "sossim.entities", "qualname": "VehicleWorldModel.__init__", "kind": "function", "doc": "<p>Initializes a vehicle world model.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">entities</span><span class=\"o\">.</span><span class=\"n\">Vehicle</span></span>)</span>"}, {"fullname": "sossim.entities.VehicleWorldModel.perceive", "modulename": "sossim.entities", "qualname": "VehicleWorldModel.perceive", "kind": "function", "doc": "<p>Updates the perception of the world as represented in this world model.\nThis is done by setting space to a subgraph of the model's space, that only contain neighboring nodes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Vehicle", "modulename": "sossim.entities", "qualname": "Vehicle", "kind": "class", "doc": "<p>A common abstract baseclass for entities within a SoS.\nAll entities are treated as agents, but not all of them have behavior.\nThis means also that they can be placed on the map, and have a unique id, which is automatically generated.</p>\n", "bases": "sossim.core.Agent"}, {"fullname": "sossim.entities.Vehicle.__init__", "modulename": "sossim.entities", "qualname": "Vehicle.__init__", "kind": "function", "doc": "<p>Creates a vehicle agent in a simulation model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>model (model.TransportSystem):</strong>  the model in which the agent is situated.</li>\n<li><strong>configuration (Configuration):</strong>  the configuration parameters.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"s1\">&#39;model.TransportSystem&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">configuration</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span></span>)</span>"}, {"fullname": "sossim.entities.Vehicle.max_load", "modulename": "sossim.entities", "qualname": "Vehicle.max_load", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;Param&#x27;, &#x27;maximum load of a vehicle&#x27;]"}, {"fullname": "sossim.entities.Vehicle.max_energy", "modulename": "sossim.entities", "qualname": "Vehicle.max_energy", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;Param&#x27;, &#x27;maximum energy of a vehicle&#x27;]"}, {"fullname": "sossim.entities.Vehicle.charging_speed", "modulename": "sossim.entities", "qualname": "Vehicle.charging_speed", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;Param&#x27;, &#x27;the charging speed of a vehicle&#x27;]"}, {"fullname": "sossim.entities.Vehicle.perception_range", "modulename": "sossim.entities", "qualname": "Vehicle.perception_range", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;Param&#x27;, &#x27;the perception range of the vehicle&#x27;]"}, {"fullname": "sossim.entities.Vehicle.energy_level", "modulename": "sossim.entities", "qualname": "Vehicle.energy_level", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;State&#x27;]"}, {"fullname": "sossim.entities.Vehicle.heading", "modulename": "sossim.entities", "qualname": "Vehicle.heading", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;State&#x27;]"}, {"fullname": "sossim.entities.Vehicle.navigator", "modulename": "sossim.entities", "qualname": "Vehicle.navigator", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.entities.Vehicle.capacity", "modulename": "sossim.entities", "qualname": "Vehicle.capacity", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.entities.Vehicle.cargos", "modulename": "sossim.entities", "qualname": "Vehicle.cargos", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[sossim.entities.Cargo]"}, {"fullname": "sossim.entities.Vehicle.can_coexist", "modulename": "sossim.entities", "qualname": "Vehicle.can_coexist", "kind": "function", "doc": "<p>Returns True if this entity can coexist in the same cell with the other entity.\nVehicles are not allowed to coexist with other vehicles.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>other (core.Entity):</strong>  another entity.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if coexistance is possible.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Entity</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Vehicle.available_cargo", "modulename": "sossim.entities", "qualname": "Vehicle.available_cargo", "kind": "function", "doc": "<p>Returns the list of available cargos in a destination node that the vehicle can carry.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Cargo]: the list of cargo.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">entities</span><span class=\"o\">.</span><span class=\"n\">Cargo</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Vehicle.random_route", "modulename": "sossim.entities", "qualname": "Vehicle.random_route", "kind": "function", "doc": "<p>Randomly choose any of the neighboring nodes which fulfils a given condition, which defaults to any node.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>condition (Callable[[Node], bool], optional):</strong>  a condition, specifying which neighboring nodes to choose from. Defaults to any node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Node: a list containing the chosen node.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">condition</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">Vehicle</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Vehicle.update_plan", "modulename": "sossim.entities", "qualname": "Vehicle.update_plan", "kind": "function", "doc": "<p>The vehicle creates a plan, which consists of randomly moving to one the neighbours in the road network.\nOccasionally, it chooses instead to find a parking.\nWhen energy level is low, it searches for an available charging point and charges energy there.</p>\n\n<p>The vehicle creates a plan according to the following principles:</p>\n\n<ul>\n<li>If it does not have a plan already, then:\n<ul>\n<li>If it has a cargo, transport it to its destination and unload it. </li>\n<li>If it does not have any cargo, then:\n<ul>\n<li>If there is a suitable cargo in the current destination, load it.</li>\n<li>Otherwise, search for a cargo to transport by randomly moving around.</li>\n</ul></li>\n</ul></li>\n<li>If it is low on energy, first search for a charging point.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Vehicle.move", "modulename": "sossim.entities", "qualname": "Vehicle.move", "kind": "function", "doc": "<p>Moves the vehicle to the given target node.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target (Node):</strong>  the new node.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Vehicle.load_capacity", "modulename": "sossim.entities", "qualname": "Vehicle.load_capacity", "kind": "function", "doc": "<p>Returns the remaining load capacity of the vehicle.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the remaining load capacity.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Vehicle.load_cargo", "modulename": "sossim.entities", "qualname": "Vehicle.load_cargo", "kind": "function", "doc": "<p>Loads the cargo onto this vehicle.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cargo (Cargo):</strong>  the cargo.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cargo</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">entities</span><span class=\"o\">.</span><span class=\"n\">Cargo</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Vehicle.unload_cargo", "modulename": "sossim.entities", "qualname": "Vehicle.unload_cargo", "kind": "function", "doc": "<p>Unload the cargo from this vehicle.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>cargo (Cargo):</strong>  the cargo.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cargo</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">entities</span><span class=\"o\">.</span><span class=\"n\">Cargo</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Cargo", "modulename": "sossim.entities", "qualname": "Cargo", "kind": "class", "doc": "<p>A cargo is an entity which can be transported by vehicles.\nIt has a weight, a position, a destination, and a carrier.</p>\n", "bases": "sossim.core.Entity"}, {"fullname": "sossim.entities.Cargo.__init__", "modulename": "sossim.entities", "qualname": "Cargo.__init__", "kind": "function", "doc": "<p>Creates a cargo entitiy in a simulation model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>model (model.TransportSystem):</strong>  the model in which the cargo is situated.</li>\n<li><strong>configuration (Configuration):</strong>  the configuration parameters.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"s1\">&#39;model.TransportSystem&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">configuration</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span></span>)</span>"}, {"fullname": "sossim.entities.Cargo.max_cargo_weight", "modulename": "sossim.entities", "qualname": "Cargo.max_cargo_weight", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;Param&#x27;, &#x27;The maximum weight of a cargo&#x27;]"}, {"fullname": "sossim.entities.Cargo.weight", "modulename": "sossim.entities", "qualname": "Cargo.weight", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.entities.Cargo.carrier", "modulename": "sossim.entities", "qualname": "Cargo.carrier", "kind": "variable", "doc": "<p></p>\n", "annotation": ": sossim.entities.Vehicle | None"}, {"fullname": "sossim.entities.Cargo.select_destination", "modulename": "sossim.entities", "qualname": "Cargo.select_destination", "kind": "function", "doc": "<p>Selects a destination for the cargo. If no destination is provided, a random one is picked.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>destination (Node, optional):</strong>  the new destination. Defaults to None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">destination</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Cargo.load_onto", "modulename": "sossim.entities", "qualname": "Cargo.load_onto", "kind": "function", "doc": "<p>The cargo gets loaded onto a carrier vehicle.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>carrier (Vehicle):</strong>  the carrier.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">carrier</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">entities</span><span class=\"o\">.</span><span class=\"n\">Vehicle</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.entities.Cargo.unload", "modulename": "sossim.entities", "qualname": "Cargo.unload", "kind": "function", "doc": "<p>The cargo gets unloaded from a carrier vehicle.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.model", "modulename": "sossim.model", "kind": "module", "doc": "<p>Provides models for the SoSSim system-of-systems simulator.</p>\n\n<p>Partial UML class diagram:</p>\n\n<pre class=\"mermaid-pre\"><div class=\"mermaid\">classDiagram\n    `core.Model` &lt;|-- TransportSystem\n    TransportSystem: step()\n    TransportSystem: manifest()\n    TransportSystem: to_archive_content(...)\n</div></pre>\n"}, {"fullname": "sossim.model.TransportSystem", "modulename": "sossim.model", "qualname": "TransportSystem", "kind": "class", "doc": "<p>A comman base class for SoS models.</p>\n", "bases": "sossim.core.Model"}, {"fullname": "sossim.model.TransportSystem.__init__", "modulename": "sossim.model", "qualname": "TransportSystem.__init__", "kind": "function", "doc": "<p>Creates a transport system model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>configuration (Configuration):</strong>  the configuration of parameters from which the model is generated.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">configuration</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span></span>)</span>"}, {"fullname": "sossim.model.TransportSystem.num_vehicles", "modulename": "sossim.model", "qualname": "TransportSystem.num_vehicles", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;Param&#x27;, &#x27;number of vehicles&#x27;]"}, {"fullname": "sossim.model.TransportSystem.num_cargos", "modulename": "sossim.model", "qualname": "TransportSystem.num_cargos", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;Param&#x27;, &#x27;number of cargos&#x27;]"}, {"fullname": "sossim.model.TransportSystem.random_seed", "modulename": "sossim.model", "qualname": "TransportSystem.random_seed", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;Param&#x27;, &#x27;seed for random number generator (use -1 to initialize from system time)&#x27;]"}, {"fullname": "sossim.model.TransportSystem.collect_data", "modulename": "sossim.model", "qualname": "TransportSystem.collect_data", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[bool, &#x27;Param&#x27;, &#x27;enable data collection of state variables&#x27;]"}, {"fullname": "sossim.model.TransportSystem.generation_start_time", "modulename": "sossim.model", "qualname": "TransportSystem.generation_start_time", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.model.TransportSystem.configuration", "modulename": "sossim.model", "qualname": "TransportSystem.configuration", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.model.TransportSystem.space", "modulename": "sossim.model", "qualname": "TransportSystem.space", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.model.TransportSystem.generation_end_time", "modulename": "sossim.model", "qualname": "TransportSystem.generation_end_time", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.model.TransportSystem.step", "modulename": "sossim.model", "qualname": "TransportSystem.step", "kind": "function", "doc": "<p>Performs a simulation step and updates the views.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.model.TransportSystem.manifest", "modulename": "sossim.model", "qualname": "TransportSystem.manifest", "kind": "function", "doc": "<p>Returns various information about the model as a dict structure.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, Any]: the manifest as a dict.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.model.TransportSystem.to_archive_content", "modulename": "sossim.model", "qualname": "TransportSystem.to_archive_content", "kind": "function", "doc": "<p>Returns the information in this model as an archive.\nThe structure of the archive is a dict whose items are file names and file content.\nThis can then easily be mapped to e.g. a zip archive.\nThe contents of the archive is a json-formatted file of the configuration.\nIf data collection was enabled, it also contains the collected data.\nThis is represented as one csv-formatted file for each table in the data collection, where the file name is the name of the table.\nThe archive also contains a manifest.json file, with various meta-information about the contents.\nIf extra arguments are provided, these should be tuples of three strings: file name, file content, and file description.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>extras:</strong>  tuple[str, str, str]: additional iterms to be added.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict[str, str]: the archive file names and content.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">extras</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space", "modulename": "sossim.space", "kind": "module", "doc": "<p>Provides spaces for the SoSSim system-of-systems simulator.\nThe space is a grid rendered as a bidirectional graph, with nodes being grid cells and with edges between all adjacent grid cells.\nAttributes can be set on nodes and edges to represent roads, destinations, etc.</p>\n\n<p>Partial UML class diagram:</p>\n\n<pre class=\"mermaid-pre\"><div class=\"mermaid\">classDiagram\n    `nx.DiGraph` &lt;|-- RoadGridGraph\n    RoadGridGraph: grid_neighbors(node, ...)\n    RoadGridGraph: add_road(source, sink, ...)\n    RoadGridGraph: add_roads(node, directions)\n    RoadGridGraph: add_destination(node1, node2, charging_point)\n    RoadGridGraph: has_road_to(source, direction)\n    RoadGridGraph: is_road(node1, [node2])\n    RoadGridGraph: road_degree(node)\n\n    `core.Space` &lt;|-- RoadNetworkGrid\n    RoadNetworkGrid --&gt; RoadGridGraph: coarse_network\n    RoadNetworkGrid --&gt; RoadGridGraph: road_network\n    RoadNetworkGrid --&gt; `core.Model`: model\n    RoadNetworkGrid: subgraph(nodes)\n    RoadNetworkGrid: generate_roads()\n    RoadNetworkGrid: priority_nodes()\n</div></pre>\n"}, {"fullname": "sossim.space.Node", "modulename": "sossim.space", "qualname": "Node", "kind": "variable", "doc": "<p></p>\n", "default_value": "sossim.space.Node"}, {"fullname": "sossim.space.Edge", "modulename": "sossim.space", "qualname": "Edge", "kind": "variable", "doc": "<p></p>\n", "default_value": "sossim.space.Edge"}, {"fullname": "sossim.space.Direction", "modulename": "sossim.space", "qualname": "Direction", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;class &#x27;int&#x27;&gt;"}, {"fullname": "sossim.space.RoadGridGraph", "modulename": "sossim.space", "qualname": "RoadGridGraph", "kind": "class", "doc": "<p>A directed graph representing a 2D grid where the edges are labelled by direction in degrees.\nRoads are represented by having the node and edge attribute \"road\" set to True.\nDestinations are represented by having the node attribute \"destination\" set to True.\nSome destinations can also have charging points.</p>\n", "bases": "networkx.classes.digraph.DiGraph"}, {"fullname": "sossim.space.RoadGridGraph.__init__", "modulename": "sossim.space", "qualname": "RoadGridGraph.__init__", "kind": "function", "doc": "<p>Creates the grid graph.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>width (int, optional):</strong>  the width of the grid. Defaults to 0.</li>\n<li><strong>height (int, optional):</strong>  the height of the grid. Defaults to 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>nx.DiGraph: the resulting graph.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">width</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span>)</span>"}, {"fullname": "sossim.space.RoadGridGraph.width", "modulename": "sossim.space", "qualname": "RoadGridGraph.width", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.space.RoadGridGraph.height", "modulename": "sossim.space", "qualname": "RoadGridGraph.height", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.space.RoadGridGraph.grid_neighbors", "modulename": "sossim.space", "qualname": "RoadGridGraph.grid_neighbors", "kind": "function", "doc": "<p>Returns a list of all grid neighbors of a node. If diagonal is False, diagonal neighbors are not included.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node (Node):</strong>  the node.</li>\n<li><strong>diagonal (bool, optional):</strong>  if True, diagonal neighbors are included. Defaults to False.</li>\n<li><strong>center (bool, optional):</strong>  if True, the given node, which is at the center of the set, is included in the result. Defaults to False.</li>\n<li><strong>dist (int, optional):</strong>  if different from 1, include all nodes at this distance. Defaults to 1.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: a list of grid neighbors.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">diagonal</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">center</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">dist</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadGridGraph.add_road", "modulename": "sossim.space", "qualname": "RoadGridGraph.add_road", "kind": "function", "doc": "<p>Adds a road from the source node to the sink node.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  source node.</li>\n<li><strong>sink (Node):</strong>  sink node.</li>\n<li><strong>bidirectional (bool, optional):</strong>  if True, the road in opposite direction is also added. Defaults to False.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">sink</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">bidirectional</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadGridGraph.add_roads", "modulename": "sossim.space", "qualname": "RoadGridGraph.add_roads", "kind": "function", "doc": "<p>Adds a sequence of roads to the network, starting in the provided node and going in the provided directions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node (Node):</strong>  the start node.</li>\n<li><strong>directions (list[Direction]):</strong>  a list containing directions in degrees.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>, </span><span class=\"param\"><span class=\"n\">directions</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadGridGraph.add_destination", "modulename": "sossim.space", "qualname": "RoadGridGraph.add_destination", "kind": "function", "doc": "<p>Adds a destination node, as a neighbor of the given node.\nRoads are added to and from the destination from the node.\nThe destination node is indicated as such using a node attribute.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node1 (Node):</strong>  the node to be connected to the destination.</li>\n<li><strong>node2 (Node):</strong>  the destination.</li>\n<li><strong>charging_point (bool, optional):</strong>  if True, the destination is a charging point. Defaults to False.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node1</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">node2</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">charging_point</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadGridGraph.has_road_to", "modulename": "sossim.space", "qualname": "RoadGridGraph.has_road_to", "kind": "function", "doc": "<p>Returns True if and only if the graph has a road from the given node in the given direction.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  the source node.</li>\n<li><strong>direction (Direction):</strong>  the direction in degrees.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: _description_</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadGridGraph.is_road", "modulename": "sossim.space", "qualname": "RoadGridGraph.is_road", "kind": "function", "doc": "<p>Checks if a node or an edge is a road. If two nodes are given, it checks the edge, otherwise the node.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node1 (Node):</strong>  a node.</li>\n<li><strong>node2 (Node, optional):</strong>  a second node, if checking an edge. Defaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the node or edge is a road.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node1</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">node2</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadGridGraph.road_degree", "modulename": "sossim.space", "qualname": "RoadGridGraph.road_degree", "kind": "function", "doc": "<p>Returns the number of outgoing roads from a node.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node (Node):</strong>  the node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: the number of outgoing roads.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.subnode", "modulename": "sossim.space", "qualname": "subnode", "kind": "function", "doc": "<p>Returns the detailed network subnode (i, j) of a coarse network node.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>, </span><span class=\"param\"><span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">j</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid", "modulename": "sossim.space", "qualname": "RoadNetworkGrid", "kind": "class", "doc": "<p>An agent space consisting of a road network which is placed on a grid.\nThe road network is a networkx graph, where node names are tuples (x, y) referring to grid positions.\nSome nodes in the road networks can be destinations, where places of interest can be placed.</p>\n", "bases": "sossim.core.Space"}, {"fullname": "sossim.space.RoadNetworkGrid.__init__", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.__init__", "kind": "function", "doc": "<p>Creates a grid of size (width, height), and adds a road network to it.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>configuration (Configuration):</strong>  the configuration of parameters from which the road network is generated.</li>\n<li><strong>model (core.Model):</strong>  the model of which this space is to be a part.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">configuration</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span>,</span><span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Model</span></span>)</span>"}, {"fullname": "sossim.space.RoadNetworkGrid.width", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.width", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;Param&#x27;, &#x27;number of grid cells in x dimension&#x27;]"}, {"fullname": "sossim.space.RoadNetworkGrid.height", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.height", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[int, &#x27;Param&#x27;, &#x27;number of grid cells in y dimension&#x27;]"}, {"fullname": "sossim.space.RoadNetworkGrid.road_density", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.road_density", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[float, &#x27;Param&#x27;, &#x27;the proportion of the grid to be covered by roads&#x27;]"}, {"fullname": "sossim.space.RoadNetworkGrid.destination_density", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.destination_density", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[float, &#x27;Param&#x27;, &#x27;probability of generating a destination in a position where it is possible&#x27;]"}, {"fullname": "sossim.space.RoadNetworkGrid.charging_point_density", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.charging_point_density", "kind": "variable", "doc": "<p></p>\n", "annotation": ": typing.Annotated[float, &#x27;Param&#x27;, &#x27;probability of a destination having a charging point&#x27;]"}, {"fullname": "sossim.space.RoadNetworkGrid.model", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.space.RoadNetworkGrid.coarse_network", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.coarse_network", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.space.RoadNetworkGrid.road_network", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.road_network", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "sossim.space.RoadNetworkGrid.subgraph", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.subgraph", "kind": "function", "doc": "<p>Creates a copy of the space, where the road network is a subgraph of the complete network, only containing the given nodes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>nodes (list[Node]):</strong>  the nodes to be included in the subgraph.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Self: the subgraph space.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">nodes</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.generate_roads", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.generate_roads", "kind": "function", "doc": "<p>Generates the road network. This is a two step process.\nFirst, a coarse undirected network is generated, where each node corresponds to a grid cell.\nHeustistics are used to try to spread this network over the grid and have a balance between dense and sprawling roads.\nSecond, this network is expanded into a directed graph, containing separate roadways and roundabouts.\nThis is achieved by dividing each coarse network node / grid cell into 4 x 4 subnodes.\nThese are connected so that traffic in all directions become possible.\nIn the resulting directed network, each node has either one or two outgoing edges.\nThe network keeps track of what agents are currently in a node.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.priority_nodes", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.priority_nodes", "kind": "function", "doc": "<p>Returns the nodes from which traffic has priority over from_node when going into to_node.\nThis is traffic coming from the left in a roundabout, and any traffic when leaving a parking.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>from_node (Node):</strong>  the node to be checked for priority.</li>\n<li><strong>to_node (Node):</strong>  the node to be checked for priority.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: a list of nodes from which vehicles have priority.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">from_node</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">to_node</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.road_nodes", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.road_nodes", "kind": "function", "doc": "<p>Returns a list of all nodes which are connected by roads.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>condition:</strong>  a condition that the nodes must satisfy. Defaults to always True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: the nodes connected by roads.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">condition</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">RoadNetworkGrid</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.destination_nodes", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.destination_nodes", "kind": "function", "doc": "<p>Returns a list of all nodes which are destinations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>condition:</strong>  a condition that the nodes must satisfy. Defaults to always True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: the destinations.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">condition</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">RoadNetworkGrid</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.road_edges", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.road_edges", "kind": "function", "doc": "<p>Returns a list of all edges that are roads.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: the nodes connected by roads.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Edge</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.roads_from", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.roads_from", "kind": "function", "doc": "<p>Returns a list of all nodes that can be reached by road from a given source node.\nIf a condition function is provided, only nodes fulfilling that condition are returned.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  the source node.</li>\n<li><strong>condition (Callable[[Node], bool], optional):</strong>  a condition on the nodes. Defaults to always True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: a list of nodes reachable by road.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">condition</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">RoadNetworkGrid</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.roads_to", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.roads_to", "kind": "function", "doc": "<p>Returns a list of all nodes that can reach the given sink node by road.\nIf a condition function is provided, only nodes fulfilling that condition are returned.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sink (Node):</strong>  the sink node.</li>\n<li><strong>condition (Callable[[Node], bool], optional):</strong>  a condition on the nodes. Defaults to always True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: a list of nodes from which the sink node can be reached by road.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">sink</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">condition</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">RoadNetworkGrid</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.is_destination", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.is_destination", "kind": "function", "doc": "<p>Checks if a node is a destination.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node (Node):</strong>  the node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the node is a destination.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.is_charging_point", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.is_charging_point", "kind": "function", "doc": "<p>Checks if a node is a charging point.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>node (Node):</strong>  the node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the node is a charging point.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.edge_direction", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.edge_direction", "kind": "function", "doc": "<p>Returns the direction of the edge going from source to sink.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  source node.</li>\n<li><strong>sink (Node):</strong>  sink node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Direction: the direction in degrees.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>, </span><span class=\"param\"><span class=\"n\">sink</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.shortest_path", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.shortest_path", "kind": "function", "doc": "<p>Returns the shortest path from source to sink as a list of nodes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  the source node.</li>\n<li><strong>target (Node):</strong>  the target node.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: the path.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.path_to_nearest", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.path_to_nearest", "kind": "function", "doc": "<p>Given a source node and a list of target nodes, return the path to the nearest of the targets.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source (Node):</strong>  the source node.</li>\n<li><strong>targets (list[Node]):</strong>  the list of target nodes.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[Node]: the path to the nearest target node.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">targets</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.has_road_to", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.has_road_to", "kind": "function", "doc": "<p>Calls the method with the same name on self.road_network.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">source</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.is_road", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.is_road", "kind": "function", "doc": "<p>Calls the method with the same name on self.road_network.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node1</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">node2</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.grid_neighbors", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.grid_neighbors", "kind": "function", "doc": "<p>Calls the method with the same name on self.road_network.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">diagonal</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">center</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">dist</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.place_agent", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.place_agent", "kind": "function", "doc": "<p>Place an agent in a node.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span>, </span><span class=\"param\"><span class=\"n\">node_id</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.get_neighborhood", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.get_neighborhood", "kind": "function", "doc": "<p>Get all adjacent nodes within a certain radius</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node_id</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">include_center</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.get_neighbors", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.get_neighbors", "kind": "function", "doc": "<p>Get all agents in adjacent nodes.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">node_id</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span>,</span><span class=\"param\">\t<span class=\"n\">include_center</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.move_agent", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.move_agent", "kind": "function", "doc": "<p>Move an agent from its current node to a new node.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span>, </span><span class=\"param\"><span class=\"n\">node_id</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.remove_agent", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.remove_agent", "kind": "function", "doc": "<p>Remove the agent from the network and set its pos attribute to None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">agent</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.is_cell_empty", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.is_cell_empty", "kind": "function", "doc": "<p>Returns a bool of the contents of a cell.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node_id</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.get_cell_list_contents", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.get_cell_list_contents", "kind": "function", "doc": "<p>Returns a list of the agents contained in the nodes identified\nin <code>cell_list</code>; nodes with empty content are excluded.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cell_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.get_all_cell_contents", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.get_all_cell_contents", "kind": "function", "doc": "<p>Returns a list of all the agents in the network.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.space.RoadNetworkGrid.iter_cell_list_contents", "modulename": "sossim.space", "qualname": "RoadNetworkGrid.iter_cell_list_contents", "kind": "function", "doc": "<p>Returns an iterator of the agents contained in the nodes identified\nin <code>cell_list</code>; nodes with empty content are excluded.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">cell_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">space</span><span class=\"o\">.</span><span class=\"n\">Node</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterator</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">Agent</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.view", "modulename": "sossim.view", "kind": "module", "doc": "<p>Module containing functionality for attaching views to model classes. <br />\n```</p>\n"}, {"fullname": "sossim.view.View", "modulename": "sossim.view", "qualname": "View", "kind": "class", "doc": "<p>Interface class for views.</p>\n", "bases": "typing.Protocol"}, {"fullname": "sossim.view.View.__init__", "modulename": "sossim.view", "qualname": "View.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "sossim.view.View.update", "modulename": "sossim.view", "qualname": "View.update", "kind": "function", "doc": "<p>Updates the view. This is an abstract function that is redefined in subclasses.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>viewable (Any):</strong>  the viewable on which the update should be based.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">viewable</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.view.Viewable", "modulename": "sossim.view", "qualname": "Viewable", "kind": "class", "doc": "<p>A mixin class for objects to which a view can be attached. \nIt adds the methods for handling views attached to the viewable, unless such a method already exists.</p>\n"}, {"fullname": "sossim.view.Viewable.add_view", "modulename": "sossim.view", "qualname": "Viewable.add_view", "kind": "function", "doc": "<p>Adds a view to the viewable object.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>view (Any):</strong>  the view.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">view</span><span class=\"p\">:</span> <span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">View</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.view.Viewable.get_views", "modulename": "sossim.view", "qualname": "Viewable.get_views", "kind": "function", "doc": "<p>Returns the list of views attached to the viewable object.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list[View]: the views.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">sossim</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"o\">.</span><span class=\"n\">View</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "sossim.view.Viewable.update_views", "modulename": "sossim.view", "qualname": "Viewable.update_views", "kind": "function", "doc": "<p>Updates the views.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim.view.Viewable.clear_views", "modulename": "sossim.view", "qualname": "Viewable.clear_views", "kind": "function", "doc": "<p>Removes all views.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "sossim", "modulename": "sossim", "kind": "module", "doc": "<p>The <code>sossim</code> package provides a simulator of transportation system.\nIt is intended to be used for experimenting with different ways of designing systems-of-systems (SoS).\nIt can be executed both from the command line and as an interactive simulation in a browser.</p>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();